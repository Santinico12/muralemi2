<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"/>
  <title>Mural AR (Three.js + jsartoolkit + VR/Cardboard)</title>

  <!-- Three.js (versi√≥n compatible con THREEx/jsartoolkit) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.110.0/build/three.min.js"></script>

  <!-- jsartoolkit y THREEx desde AR.js 3.4.5 (CDN sin 404) -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/3.4.5/three.js/vendor/jsartoolkit5/build/artoolkit.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/3.4.5/three.js/vendor/jsartoolkit5/js/artoolkit.api.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/3.4.5/three.js/src/threex/threex-artoolkitsource.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/3.4.5/three.js/src/threex/threex-artoolkitcontext.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/3.4.5/three.js/src/threex/threex-arbasecontrols.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/3.4.5/three.js/src/threex/threex-armarkercontrols.js"></script>

  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #hud { position:fixed; top:10px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,.55); color:#fff; padding:10px 14px; border-radius:10px; z-index:10; text-align:center; }
    #controls { position:fixed; bottom:10px; left:0; right:0; display:flex; gap:10px; justify-content:center; z-index:10; }
    #controls button { padding:10px 12px; border:0; border-radius:10px; cursor:pointer; font-weight:600; background:rgba(255,255,255,.15); color:#fff; backdrop-filter: blur(4px); }
    #loader { position:fixed; inset:0; display:grid; place-items:center; background:#000; color:#fff; z-index:9999; }
    canvas { position:fixed; inset:0; width:100vw; height:100vh; display:block; }
    video#muralvid { display:none; }
  </style>
</head>
<body>

  <div id="loader">Cargando AR‚Ä¶ üì±</div>

  <div id="hud">
    <b>Mural AR</b> ¬∑ Apunta al marcador <b>Hiro</b>
  </div>

  <div id="controls">
    <button id="btnStart">‚ñ∂Ô∏è Iniciar AR</button>
    <button id="btnAudio" style="display:none">üîà Activar sonido</button>
    <button id="btnVR" style="display:none">üï∂Ô∏è Activar VR</button>
  </div>

  <!-- TU video: debe existir en la ra√≠z como /video.mp4 -->
  <video id="muralvid"
         src="video.mp4"
         preload="auto"
         loop
         muted
         playsinline
         webkit-playsinline
         crossorigin="anonymous"></video>

<script>
let scene, camera, renderer, clock;
let arToolkitSource, arToolkitContext;
let markerRoot, planeMesh, frameMesh;
let videoEl, videoTex;

let stereoMode = false;
const IPD = 0.064; // ~64mm
const stereoCams = { left:null, right:null };

init();
animate();

function init(){
  // escena y luz
  scene = new THREE.Scene();
  scene.add(new THREE.AmbientLight(0xffffff, 0.8));

  // c√°mara AR
  camera = new THREE.Camera();
  scene.add(camera);

  // renderer
  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.setClearColor(0x000000, 0);
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  clock = new THREE.Clock();

  // fuente webcam
  arToolkitSource = new THREEx.ArToolkitSource({ sourceType:'webcam' });

  const onResize = () => {
    arToolkitSource.onResize();
    arToolkitSource.copySizeTo(renderer.domElement);
    if (arToolkitContext.arController){
      arToolkitSource.copySizeTo(arToolkitContext.arController.canvas);
    }
  };

  arToolkitSource.init(() => {
    onResize();
    document.getElementById('loader').style.display = 'none';
    document.getElementById('btnVR').style.display = 'inline-block';
  });

  window.addEventListener('resize', onResize);

  // contexto AR
  arToolkitContext = new THREEx.ArToolkitContext({
    cameraParametersUrl: 'https://raw.githack.com/AR-js-org/AR.js/3.4.5/three.js/data/camera_para.dat',
    detectionMode: 'mono'
  });

  arToolkitContext.init(() => {
    camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
  });

  // marcador Hiro
  markerRoot = new THREE.Group();
  scene.add(markerRoot);

  new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
    type: 'pattern',
    patternUrl: 'https://raw.githack.com/AR-js-org/AR.js/3.4.5/three.js/data/patt.hiro'
  });

  // plano con textura de video
  const geom = new THREE.PlaneBufferGeometry(2, 1.125, 2, 2); // 16:9 por defecto
  videoEl = document.getElementById('muralvid');
  videoTex = new THREE.VideoTexture(videoEl);
  videoTex.minFilter = THREE.LinearFilter;
  videoTex.magFilter = THREE.LinearFilter;
  videoTex.format   = THREE.RGBFormat;

  const mat = new THREE.MeshBasicMaterial({ map: videoTex, side: THREE.DoubleSide });
  planeMesh = new THREE.Mesh(geom, mat);
  planeMesh.rotation.x = -Math.PI/2;
  planeMesh.position.set(0, 0, 0.02);
  markerRoot.add(planeMesh);

  // marco decorativo (opcional)
  const frameGeom = new THREE.BoxBufferGeometry(2.2, 0.08, 1.3);
  const frameMat  = new THREE.MeshBasicMaterial({ color: 0x654321 });
  frameMesh = new THREE.Mesh(frameGeom, frameMat);
  frameMesh.rotation.x = -Math.PI/2;
  frameMesh.position.set(0, 0, -0.05);
  markerRoot.add(frameMesh);

  // UI
  wireUI();
}

function wireUI(){
  const btnStart = document.getElementById('btnStart');
  const btnAudio = document.getElementById('btnAudio');
  const btnVR    = document.getElementById('btnVR');

  btnStart.addEventListener('click', () => {
    // autoplay m√≥vil: mute + playsInline y gesto del usuario
    videoEl.muted = true;
    videoEl.playsInline = true;
    videoEl.load(); // asegura que tome src correcto
    const tryPlay = () => videoEl.play().catch(()=>setTimeout(tryPlay, 250));
    tryPlay();

    if (videoEl.readyState >= 1) fitPlaneToVideo();
    else videoEl.addEventListener('loadedmetadata', fitPlaneToVideo, {once:true});

    btnAudio.style.display = 'inline-block';
  });

  btnAudio.addEventListener('click', async () => {
    try {
      videoEl.muted = !videoEl.muted;
      await videoEl.play();
      btnAudio.textContent = videoEl.muted ? 'üîà Activar sonido' : 'üîá Silenciar';
    } catch(e){ console.warn('Audio toggle error', e); }
  });

  btnVR.addEventListener('click', () => {
    stereoMode = !stereoMode;
    btnVR.textContent = stereoMode ? '‚Ü©Ô∏è Salir VR' : 'üï∂Ô∏è Activar VR';
    if (stereoMode) setupStereoCameras(); else teardownStereoCameras();
  });

  document.addEventListener('visibilitychange', () => {
    if (!document.hidden && videoEl && videoEl.paused) videoEl.play().catch(()=>{});
  });
}

function fitPlaneToVideo(){
  if (!videoEl.videoWidth || !videoEl.videoHeight) return;
  const aspect = videoEl.videoWidth / videoEl.videoHeight;
  const W = 2;
  const H = W / aspect;
  planeMesh.geometry.dispose();
  planeMesh.geometry = new THREE.PlaneBufferGeometry(W, H, 2, 2);
  planeMesh.geometry.needsUpdate = true;
  // ajusta el marco
  frameMesh.scale.set(W/2, 1, H/1.3);
  console.log('[AR] video aspect', aspect.toFixed(3), 'plane', W.toFixed(2)+'x'+H.toFixed(2));
}

function setupStereoCameras(){
  stereoCams.left  = new THREE.PerspectiveCamera();
  stereoCams.right = new THREE.PerspectiveCamera();
}
function teardownStereoCameras(){
  stereoCams.left = stereoCams.right = null;
  renderer.setScissorTest(false);
}

function animate(){
  requestAnimationFrame(animate);

  if (arToolkitSource.ready){
    arToolkitContext.update(arToolkitSource.domElement);
  }

  if (!stereoMode || !stereoCams.left){
    renderer.setScissorTest(false);
    renderer.render(scene, camera);
  } else {
    renderStereo();
  }
}

function renderStereo(){
  const w = renderer.domElement.width;
  const h = renderer.domElement.height;
  renderer.setScissorTest(true);

  // proyecci√≥n AR a cada ojo
  stereoCams.left.projectionMatrix.copy(camera.projectionMatrix);
  stereoCams.right.projectionMatrix.copy(camera.projectionMatrix);

  stereoCams.left.matrixWorld.copy(camera.matrixWorld);
  stereoCams.right.matrixWorld.copy(camera.matrixWorld);

  const halfIPD = IPD * 0.5; // ~0.032 m
  stereoCams.left.translateX(-halfIPD);
  stereoCams.right.translateX(halfIPD);

  stereoCams.left.matrixWorldInverse.copy(stereoCams.left.matrixWorld).invert();
  stereoCams.right.matrixWorldInverse.copy(stereoCams.right.matrixWorld).invert();

  // ojo izquierdo
  renderer.setViewport(0, 0, w/2, h);
  renderer.setScissor(0, 0, w/2, h);
  renderer.render(scene, stereoCams.left);

  // ojo derecho
  renderer.setViewport(w/2, 0, w/2, h);
  renderer.setScissor(w/2, 0, w/2, h);
  renderer.render(scene, stereoCams.right);
}
</script>
</body>
</html>





