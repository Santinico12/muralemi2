<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"/>
  <title>Mural AR (Three.js + jsartoolkit + VR/Cardboard)</title>

  <!-- Tu stack que funciona -->
  <script src="js/three.js"></script>
  <script src="jsartoolkit5/artoolkit.min.js"></script>
  <script src="jsartoolkit5/artoolkit.api.js"></script>
  <script src="threex/threex-artoolkitsource.js"></script>
  <script src="threex/threex-artoolkitcontext.js"></script>
  <script src="threex/threex-arbasecontrols.js"></script>
  <script src="threex/threex-armarkercontrols.js"></script>

  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #hud { position:fixed; top:10px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,.55); color:#fff; padding:10px 14px; border-radius:10px; z-index:10; text-align:center; }
    #controls { position:fixed; bottom:10px; left:0; right:0; display:flex; gap:10px; justify-content:center; z-index:10; }
    #controls button { padding:10px 12px; border:0; border-radius:10px; cursor:pointer; font-weight:600; background:rgba(255,255,255,.15); color:#fff; backdrop-filter: blur(4px); }
    #loader { position:fixed; inset:0; display:grid; place-items:center; background:#000; color:#fff; z-index:9999; }
    /* canvas a pantalla completa */
    canvas { position:fixed; inset:0; width:100vw; height:100vh; display:block; }
    video#muralvid { display:none; }
  </style>
</head>
<body>

  <div id="loader">Cargando AR‚Ä¶ v4üì±</div>

  <div id="hud">
    <b>Mural AR</b> ¬∑ Apunta al marcador <b>Hiro</b>
  </div>

  <div id="controls">
    <button id="btnStart">‚ñ∂Ô∏è Iniciar AR</button>
    <button id="btnAudio" style="display:none">üîà Activar sonido</button>
    <button id="btnVR" style="display:none">üï∂Ô∏è Activar VR</button>
  </div>

  <!-- Tu video del mural -->
  <video id="muralvid"
         src="video.mp4"
         preload="auto"
         loop
         muted
         playsinline
         webkit-playsinline
         crossorigin="anonymous"></video>

<script>
/* === Variables base === */
let scene, camera, renderer, clock;
let arToolkitSource, arToolkitContext;
let markerRoot, planeMesh, frameMesh;
let videoEl, videoTex;

let stereoMode = false;           // VR/Cardboard ON/OFF
const IPD = 0.064;                // distancia interpupilar ~64mm
const stereoCams = { left:null, right:null };

/* === Init === */
init();
animate();

/* ----------- Inicializaci√≥n ----------- */
function init(){
  // escena y luces
  scene = new THREE.Scene();
  const amb = new THREE.AmbientLight(0xffffff, 0.7);
  scene.add(amb);

  // c√°mara (ARToolkit escribir√° su proyecci√≥n)
  camera = new THREE.Camera();
  scene.add(camera);

  // renderer
  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, preserveDrawingBuffer:false });
  renderer.setClearColor(0x000000, 0);
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  clock = new THREE.Clock();

  // fuente de c√°mara (webcam)
  arToolkitSource = new THREEx.ArToolkitSource({ sourceType:'webcam' });

  const onResize = () => {
    arToolkitSource.onResize();
    arToolkitSource.copySizeTo(renderer.domElement);
    if (arToolkitContext.arController) {
      arToolkitSource.copySizeTo(arToolkitContext.arController.canvas);
    }
  };
  arToolkitSource.init(() => {
    onResize();
    document.getElementById('loader').style.display = 'none';
    document.getElementById('btnVR').style.display = 'inline-block'; // mostrar VR una vez inicia
  });
  window.addEventListener('resize', onResize);

  // contexto AR
  arToolkitContext = new THREEx.ArToolkitContext({
    cameraParametersUrl: 'data/camera_para.dat',
    detectionMode: 'mono'
  });
  arToolkitContext.init(() => {
    camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
  });

  // marker
  markerRoot = new THREE.Group();
  scene.add(markerRoot);
  new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
    type:'pattern',
    patternUrl:'data/hiro.patt'
  });

  // plano del mural (video)
  const geometry = new THREE.PlaneBufferGeometry(2, 1.125, 2, 2); // 16:9 por defecto
  videoEl = document.getElementById('muralvid');
  videoTex = new THREE.VideoTexture(videoEl);
  videoTex.minFilter = THREE.LinearFilter;
  videoTex.magFilter = THREE.LinearFilter;
  videoTex.format   = THREE.RGBFormat;
  const material = new THREE.MeshBasicMaterial({ map: videoTex, side: THREE.DoubleSide });
  planeMesh = new THREE.Mesh(geometry, material);
  planeMesh.rotation.x = -Math.PI/2;
  planeMesh.position.set(0, 0, 0.02);
  markerRoot.add(planeMesh);

  // marco decorativo detr√°s (opcional)
  const frameGeom = new THREE.BoxBufferGeometry(2.2, 0.08, 1.3);
  const frameMat  = new THREE.MeshBasicMaterial({ color: 0x654321 });
  frameMesh = new THREE.Mesh(frameGeom, frameMat);
  // el box est√° en Y=alto, Z=profundo en coord locales del marker (rotaremos)
  frameMesh.rotation.x = -Math.PI/2;
  frameMesh.position.set(0, 0, -0.05);
  markerRoot.add(frameMesh);

  // UI
  wireUI();
}

/* ----------- UI (Start / Audio / VR) ----------- */
function wireUI(){
  const btnStart = document.getElementById('btnStart');
  const btnAudio = document.getElementById('btnAudio');
  const btnVR    = document.getElementById('btnVR');

  btnStart.addEventListener('click', () => {
    // autoplay m√≥vil requiere muted + playsinline
    videoEl.muted = true;
    videoEl.playsInline = true;
    const tryPlay = () => videoEl.play().catch(()=>setTimeout(tryPlay, 250));
    tryPlay();

    // ajustar aspect ratio real cuando cargue metadata
    if (videoEl.readyState >= 1) fitPlaneToVideo();
    else videoEl.addEventListener('loadedmetadata', fitPlaneToVideo, { once:true });

    btnAudio.style.display = 'inline-block';
  });

  btnAudio.addEventListener('click', async () => {
    try {
      videoEl.muted = !videoEl.muted;
      await videoEl.play();
      btnAudio.textContent = videoEl.muted ? 'üîà Activar sonido' : 'üîá Silenciar';
    } catch(e){ console.warn('Audio toggle error', e); }
  });

  btnVR.addEventListener('click', () => {
    stereoMode = !stereoMode;
    btnVR.textContent = stereoMode ? '‚Ü©Ô∏è Salir VR' : 'üï∂Ô∏è Activar VR';
    if (stereoMode) setupStereoCameras();
    else teardownStereoCameras();
  });

  // si la app vuelve al foreground, reintenta play del video
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden && videoEl && videoEl.paused) {
      videoEl.play().catch(()=>{});
    }
  });
}

/* ----------- Ajustar tama√±o del plano al aspecto del video ----------- */
function fitPlaneToVideo(){
  if (!videoEl.videoWidth || !videoEl.videoHeight) return;
  const aspect = videoEl.videoWidth / videoEl.videoHeight;
  const baseW = 2;                 // ‚Äúancho‚Äù del mural en metros
  const baseH = baseW / aspect;
  planeMesh.geometry.dispose();
  planeMesh.geometry = new THREE.PlaneBufferGeometry(baseW, baseH, 2, 2);
  planeMesh.geometry.needsUpdate = true;
  // tambi√©n reajusta el marco para que no tape
  frameMesh.scale.set( baseW/2, 1, baseH/1.3 );
}

/* ----------- Est√©reo (Cardboard) sin dependencias ----------- */
function setupStereoCameras(){
  stereoCams.left  = new THREE.PerspectiveCamera();
  stereoCams.right = new THREE.PerspectiveCamera();
}
function teardownStereoCameras(){
  stereoCams.left = stereoCams.right = null;
  renderer.setScissorTest(false);
}

/* ----------- Bucle ----------- */
function animate(){
  requestAnimationFrame(animate);
  const delta = clock.getDelta();

  // actualizar ARToolkit cada frame
  if (arToolkitSource.ready) {
    arToolkitContext.update(arToolkitSource.domElement);
  }

  // render normal o estereosc√≥pico
  if (!stereoMode || !stereoCams.left){
    renderer.setScissorTest(false);
    renderer.render(scene, camera);
  } else {
    renderStereo();
  }
}

/* ----------- Render estereosc√≥pico ----------- */
function renderStereo(){
  const w = renderer.domElement.width;
  const h = renderer.domElement.height;
  renderer.setScissorTest(true);

  // copia proyecci√≥n (ARToolkit la gestiona)
  stereoCams.left.projectionMatrix.copy(camera.projectionMatrix);
  stereoCams.right.projectionMatrix.copy(camera.projectionMatrix);

  // copia pose base y aplica peque√±a separaci√≥n en X
  stereoCams.left.matrixWorld.copy(camera.matrixWorld);
  stereoCams.right.matrixWorld.copy(camera.matrixWorld);
  // El mundo est√° en ‚Äúmetros‚Äù ‚âà usa ~0.032 m por ojo
  const halfIPD = IPD * 0.5; // 0.032
  stereoCams.left.translateX(-halfIPD);
  stereoCams.right.translateX(halfIPD);

  stereoCams.left.matrixWorldInverse.copy(stereoCams.left.matrixWorld).invert();
  stereoCams.right.matrixWorldInverse.copy(stereoCams.right.matrixWorld).invert();

  // Ojo izquierdo
  renderer.setViewport(0, 0, w/2, h);
  renderer.setScissor(0, 0, w/2, h);
  renderer.render(scene, stereoCams.left);

  // Ojo derecho
  renderer.setViewport(w/2, 0, w/2, h);
  renderer.setScissor(w/2, 0, w/2, h);
  renderer.render(scene, stereoCams.right);
}

</script>
</body>
</html>




