<!DOCTYPE html>
<html lang="es">
<head>
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <title>Mural AR + Controles</title>

  <!-- Librer√≠as locales que ya tienes en tu repo -->
  <script src="three.js"></script>
  <script src="artoolkit.min.js"></script>
  <script src="artoolkit.api.js"></script>
  <script src="threex-artoolkitsource.js"></script>
  <script src="threex-artoolkitcontext.js"></script>
  <script src="threex-arbasecontrols.js"></script>
  <script src="threex-armarkercontrols.js"></script>

  <style>
    body { margin:0; overflow:hidden; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, Monospace; background:#000; }
    #ui {
      position:fixed; left:0; right:0; bottom:10px; z-index:10;
      display:flex; gap:10px; justify-content:center; align-items:center;
    }
    #ui button {
      padding:10px 12px; border:0; border-radius:10px; cursor:pointer;
      font-weight:600; background:rgba(255,255,255,.15); color:#fff; backdrop-filter:blur(4px);
    }
    #hud {
      position:fixed; top:10px; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,.55); color:#fff; padding:8px 14px; border-radius:10px; z-index:10;
    }
    canvas { position:fixed; inset:0; width:100vw; height:100vh; display:block; }
    /* Ocultamos el tag de video fuente */
    #video { display:none; }
  </style>
</head>

<body>

  <div id="hud"><b>Mural AR</b> ¬∑ Apunta al marcador <b>Hiro</b></div>

  <!-- Controles -->
  <div id="ui">
    <button id="btnPlay">‚èØ Reproducir</button>
    <button id="btnMute">üîà Activar sonido</button>
    <button id="btnRestart">‚ü≤ Reiniciar</button>
    <button id="btnVR">üï∂Ô∏è Activar VR</button>
  </div>

  <!-- Tu video -->
  <video id="video" autoplay loop playsinline webkit-playsinline muted crossorigin="anonymous">
    <!-- usa tu mismo archivo en ambos <source> para compatibilidad, como ten√≠as -->
    <source src="video.mp4" type='video/ogg; codecs="theora, vorbis"'>
    <source src="video.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
  </video>

<script>
/* ==== Variables de tu app (se mantienen) ==== */
var scene, camera, renderer, clock, deltaTime, totalTime;
var arToolkitSource, arToolkitContext;
var markerRoot1, mesh1;
var videoEl, videoTex;

/* ==== A√±adidos para VR/Cardboard ==== */
var stereoMode = false;
var IPD = 0.064; // ~64 mm
var stereoCams = { left: null, right: null };

/* ==== UI ==== */
var btnPlay, btnMute, btnRestart, btnVR;

initialize();
animate();

/* ----------------- Tu initialize() extendido ----------------- */
function initialize() {
  scene = new THREE.Scene();

  let ambientLight = new THREE.AmbientLight(0xcccccc, 0.5);
  scene.add(ambientLight);

  camera = new THREE.Camera();
  scene.add(camera);

  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.setClearColor(new THREE.Color('lightgrey'), 0);
  renderer.setSize(640, 480);
  renderer.domElement.style.position = 'absolute';
  renderer.domElement.style.top = '0px';
  renderer.domElement.style.left = '0px';
  document.body.appendChild(renderer.domElement);

  clock = new THREE.Clock();
  deltaTime = 0;
  totalTime = 0;

  // ====== ARToolkitSource ======
  arToolkitSource = new THREEx.ArToolkitSource({ sourceType: 'webcam' });

  function onResize() {
    arToolkitSource.onResize();
    arToolkitSource.copySizeTo(renderer.domElement);
    if (arToolkitContext.arController !== null) {
      arToolkitSource.copySizeTo(arToolkitContext.arController.canvas);
    }
  }

  arToolkitSource.init(function onReady() { onResize(); });
  window.addEventListener('resize', onResize);

  // ====== ARToolkitContext ======
  arToolkitContext = new THREEx.ArToolkitContext({
    cameraParametersUrl: 'camera_para.dat', // tus rutas locales
    detectionMode: 'mono'
  });

  arToolkitContext.init(function onCompleted() {
    camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
  });

  // ====== Marker ======
  markerRoot1 = new THREE.Group();
  scene.add(markerRoot1);
  let markerControls1 = new THREEx.ArMarkerControls(arToolkitContext, markerRoot1, {
    type: 'pattern', patternUrl: 'hiro.patt'
  });

  // ====== Plano con VideoTexture (tu c√≥digo, con variable global) ======
  var geometry1 = new THREE.PlaneBufferGeometry(2, 2, 4, 4);

  videoEl = document.getElementById('video');  // (global)
  // reforzamos flags m√≥viles (no afectan desktop)
  videoEl.muted = true;
  videoEl.playsInline = true;

  videoTex = new THREE.VideoTexture(videoEl);
  videoTex.minFilter = THREE.LinearFilter;
  videoTex.magFilter = THREE.LinearFilter;
  videoTex.format    = THREE.RGBFormat;

  var material1 = new THREE.MeshBasicMaterial({ map: videoTex, side: THREE.DoubleSide });

  mesh1 = new THREE.Mesh(geometry1, material1);
  mesh1.rotation.x = -Math.PI / 2;
  markerRoot1.add(mesh1);

  // ====== UI wiring ======
  wireUI();
}

/* ----------------- UI ----------------- */
function wireUI() {
  btnPlay    = document.getElementById('btnPlay');
  btnMute    = document.getElementById('btnMute');
  btnRestart = document.getElementById('btnRestart');
  btnVR      = document.getElementById('btnVR');

  // Estado inicial botones
  updatePlayLabel();
  updateMuteLabel();
  updateVRLabel();

  btnPlay.addEventListener('click', async function () {
    try {
      if (videoEl.paused) {
        await videoEl.play();
      } else {
        videoEl.pause();
      }
      updatePlayLabel();
    } catch (e) { console.warn('play/pause error', e); }
  });

  btnMute.addEventListener('click', async function () {
    try {
      videoEl.muted = !videoEl.muted;
      await videoEl.play().catch(()=>{});
      updateMuteLabel();
    } catch (e) { console.warn('mute toggle error', e); }
  });

  btnRestart.addEventListener('click', async function () {
    try {
      videoEl.currentTime = 0;
      await videoEl.play().catch(()=>{});
      updatePlayLabel();
    } catch (e) { console.warn('restart error', e); }
  });

  btnVR.addEventListener('click', function () {
    stereoMode = !stereoMode;
    if (stereoMode && (!stereoCams.left || !stereoCams.right)) {
      setupStereoCameras();
    }
    if (!stereoMode) teardownStereoCameras();
    updateVRLabel();
  });

  // Si vuelve del background, reintenta play (m√≥vil)
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden && videoEl.paused) videoEl.play().catch(()=>{});
  });

  // Cuando el video tenga metadata, ajusta el tama√±o del plano a su aspecto
  videoEl.addEventListener('loadedmetadata', fitPlaneToVideo, { once:true });
  if (videoEl.readyState >= 1) fitPlaneToVideo();
}

function updatePlayLabel() {
  btnPlay.textContent = videoEl && !videoEl.paused ? '‚è∏ Pausar' : '‚ñ∂Ô∏è Reproducir';
}

function updateMuteLabel() {
  btnMute.textContent = videoEl && !videoEl.muted ? 'üîá Silenciar' : 'üîà Activar sonido';
}

function updateVRLabel() {
  btnVR.textContent = stereoMode ? '‚Ü©Ô∏è Salir VR' : 'üï∂Ô∏è Activar VR';
}

/* Ajusta el tama√±o del plano al aspect real del video */
function fitPlaneToVideo() {
  if (!videoEl.videoWidth || !videoEl.videoHeight) return;
  var aspect = videoEl.videoWidth / videoEl.videoHeight;
  var W = 2;             // ancho ‚Äúmural‚Äù
  var H = W / aspect;    // alto seg√∫n aspecto
  mesh1.geometry.dispose();
  mesh1.geometry = new THREE.PlaneBufferGeometry(W, H, 4, 4);
  mesh1.geometry.needsUpdate = true;
}

/* ----------------- VR/Cardboard simple (est√©reo) ----------------- */
function setupStereoCameras() {
  stereoCams.left  = new THREE.PerspectiveCamera();
  stereoCams.right = new THREE.PerspectiveCamera();
}

function teardownStereoCameras() {
  stereoCams.left = stereoCams.right = null;
  renderer.setScissorTest(false);
}

/* ----------------- Tu update() intacto ----------------- */
function update() {
  if (arToolkitSource.ready !== false) {
    arToolkitContext.update(arToolkitSource.domElement);
  }
}

/* ----------------- render(): a√±ade est√©reo sin romper el flujo ----------------- */
function render() {
  if (!stereoMode || !stereoCams.left) {
    // Render normal (tu comportamiento original)
    renderer.setScissorTest(false);
    renderer.render(scene, camera);
    return;
  }

  // Render estereosc√≥pico (dos ‚Äúojos‚Äù)
  var w = renderer.domElement.width;
  var h = renderer.domElement.height;
  renderer.setScissorTest(true);

  // Copiar proyecci√≥n AR a ambos ojos
  stereoCams.left.projectionMatrix.copy(camera.projectionMatrix);
  stereoCams.right.projectionMatrix.copy(camera.projectionMatrix);

  // Copiar pose base y aplicar peque√±a separaci√≥n en X
  stereoCams.left.matrixWorld.copy(camera.matrixWorld);
  stereoCams.right.matrixWorld.copy(camera.matrixWorld);

  var halfIPD = IPD * 0.5; // ~0.032 m
  stereoCams.left.translateX(-halfIPD);
  stereoCams.right.translateX(halfIPD);

  stereoCams.left.matrixWorldInverse.copy(stereoCams.left.matrixWorld).invert();
  stereoCams.right.matrixWorldInverse.copy(stereoCams.right.matrixWorld).invert();

  // Ojo izquierdo
  renderer.setViewport(0, 0, w/2, h);
  renderer.setScissor(0, 0, w/2, h);
  renderer.render(scene, stereoCams.left);

  // Ojo derecho
  renderer.setViewport(w/2, 0, w/2, h);
  renderer.setScissor(w/2, 0, w/2, h);
  renderer.render(scene, stereoCams.right);
}

/* ----------------- Tu animate() intacto ----------------- */
function animate() {
  requestAnimationFrame(animate);
  deltaTime = clock.getDelta();
  totalTime += deltaTime;
  update();
  render();
}
</script>

</body>
</html>
